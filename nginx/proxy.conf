# Nginx proxy examples for three backend sites
# Replace web1.internal, web2.internal, web3.internal with your internal hostnames/IPs.
# Choose either the SUBDOMAIN approach (recommended) or the PATH approach (works but may need HTML rewriting).

##############################
# SUBDOMAIN approach (recommended)
# DNS: site1.proxy.example.com, site2.proxy.example.com, site3.proxy.example.com -> public proxy IP
##############################

# Site 1
server {
    listen 80;
    server_name site1.proxy.example.com;

    location / {
        # proxy to docker-compose service 'web1' on port 8080
        proxy_pass http://web1:8080; # upstream backend
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;

        # If backend sets Location headers with absolute URLs, rewrite them
        proxy_redirect http://web1:8080/ /;
        proxy_cookie_domain web1 proxy.example.com;
    }
}

# Site 2
server {
    listen 80;
    server_name site2.proxy.example.com;

    location / {
        proxy_pass http://web2:8090;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
        proxy_redirect http://web2:8090/ /;
        proxy_cookie_domain web2 proxy.example.com;
    }
}

# Site 3
server {
    listen 80;
    server_name site3.proxy.example.com;

    location / {
        proxy_pass http://web3:8100;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
        proxy_redirect http://web3:8100/ /;
        proxy_cookie_domain web3 proxy.example.com;
    }
}

##############################
# PATH approach (alternate)
# Expose backends under /site1/, /site2/, /site3/ on proxy.example.com
# This requires prefix stripping and typically some HTML/body rewriting for absolute links.
##############################

server {
    listen 80 default_server;
    # Accept any Host header as the default server so path-based access
    # (e.g. http://localhost/site1/) works without DNS entries.
    server_name _;

    # Site1 under /site1/
    location /site1/ {
        # Note the trailing slash on proxy_pass: it causes nginx to replace the matching
        # part of the request (/site1/) with "/" when proxying to backend.
        proxy_pass http://web1:8080/;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;

        # Rewrite redirects coming from backend
        proxy_redirect http://web1:8080/ /site1/;
        # Rewrite backend cookie domains if necessary
        proxy_cookie_domain web1 proxy.example.com;

        # Basic HTML rewriting for body occurrences of the backend host (brittle)
        # Only enabled for text/html responses
        sub_filter_types text/html;
        sub_filter_once off;
    sub_filter 'http://web1:8080' '/site1';
        proxy_set_header Accept-Encoding ""; # disable gzip from backend so sub_filter can operate
    }

    # Site2 under /site2/
    location /site2/ {
    proxy_pass http://web2:8090/;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
    proxy_redirect http://web2:8090/ /site2/;
    proxy_cookie_domain web2 proxy.example.com;
        sub_filter_types text/html;
        sub_filter_once off;
    sub_filter 'http://web2:8090' '/site2';
        proxy_set_header Accept-Encoding "";
    }

    # Site3 under /site3/
    location /site3/ {
    proxy_pass http://web3:8100/;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
    proxy_redirect http://web3:8100/ /site3/;
    proxy_cookie_domain web3 proxy.example.com;
        sub_filter_types text/html;
        sub_filter_once off;
    sub_filter 'http://web3:8100' '/site3';
        proxy_set_header Accept-Encoding "";
    }
}

# Notes:
# - Replace web1.internal / web2.internal / web3.internal with the real internal addresses
# - For TLS, add "listen 443 ssl;" blocks and certificates (Let's Encrypt or your own)
# - For SPAs and complex JS apps, prefer the subdomain approach to avoid brittle body rewriting
# - You may also add caching, rate-limiting, and other proxy directives as needed
